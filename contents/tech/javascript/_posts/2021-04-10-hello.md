---
layout:   post
title:    "javascript で非同期通信"
date:     2021-04-10 21:24:34 +0900
---

## なぜ
　Novel ページのビューアーが一段落して、次に何か触ろうかと思い、 Youtube API でも触ってみようかと思ったら、非同期通信を使ってAPIを呼び出すらしく、それが最高に分からない、だからいろいろ調べた。

　ちなみに、非同期通信じゃなくて同期通信でAPIを呼び出すことも出来るようだが、サーバーのレスポンスが遅かった場合、画面上ではフリーズしたみたいになる（らしい）ので、非同期通信でAPIを呼び出すのが一般的である（らしい）。

　否が応でも非同期通信とやらを知る必要が出てきてしまったわけである。

## 非同期通信
　非同期通信とは、処理の終了を待たないで次の処理を実行する、ということで良いだろう。

　通常、1行目の処理が完了してから2行目の処理を実行する。1行目に`"Hello"`, 2行目に`"World"`と来たら、出力は`Hello World` となる。

　ここで、1行目だけを非同期の処理にした場合、1行目の処理の完了を待たずに2行目の処理が実行されるわけなので、出力は`World Hello`のようになってしまう、という話である。

　`Hello World` だろうが、 `World Hello` だろうがどっちでも構わない。処理さえ完了してくれればいいんだというのなら問題ない。並列処理させておけば良い。しかし、1行目を非同期にした状態でなおかつ `Hello World` と順番に出力されなくてはならないのだ、という時には何か手を打たなくてはいけない。

　そこで、コールバックという手法を用いることになる。

### コールバック
　コールバックとは、ある関数内で別の関数を実行するように外から指定する手法である。つまりは関数を渡してそれを関数内で呼び出してもらうわけである。この関数をコールバック関数と呼ぶらしいのだが、C言語で言えば関数ポインタなわけでこっちの方が個人的にはわかりやすい。ともあれ、コールバック関数を渡すことで、非同期処理の問題点を解決する。

　1行目の `Hello` にコールバック関数を渡す、この時、渡すコールバック関数の中で `World` と出力するようにしておくのである。そうすれば、`Hello` の出力処理が終わろうが終わるまいが、 `World` が出力されるのは必ず、`Hello` の後なわけだから、 `Hello World` という文字列が完成する。

　これで何も問題はない。と思われたが、コールバック地獄という状態に遭遇することになる。

#### コールバック地獄
　例えば、`Hello World Hoge Fuga` と出力したかったとした場合、

- Hello には World を出力するコールバック関数を
- World には Hoge を出力するコールバック関数を
- Hoge には Fuga を出力するコールバック関数を

　渡すことで実現出来る。

　一つここで加えておくが、 World 以降も非同期になった事にしてほしい。どっかに `Hello` を貰いに行った（非同期通信）後に、 `World` を貰いに行って（非同期通信）、 `Hoge` `Fuga` も同様に貰いに行った（非同期通信）という話になったと考えてほしい。

　この状況を想定すると、関数のネスト状態が連続しているのがわかるだろうか。 最初のコールバックで `World` が出力され、次のコールバックで、とネストが深くなっていく。

　これがコールバック地獄と呼ばれるものになる。

　ネストは深いよりも浅い方が良い。別にネストが深かろうがわかるならいいじゃないかと思うかもしれないが、それならアセンブラとRubyを比較した時に、どっちでもやってることが一緒なんだからアセンブラで全部書けばいいじゃないか、と言っているのと同じことになる。ネストが浅い方が良いというのはつまり、分かりやすい方が良いという意味合いである。分かるか分からないかではない。

　これを解決する手法として、 Promise が登場する。

### Promise
　Promise は新しい記法であり、端的に言えば、コールバック地獄を解決するものであり、さらに言えば、何らかの処理完了後に任意の処理を実行することが出来る仕組みと言える。

　Promise はオブジェクトである。従って new するのだが、この時のコンストラクタに非同期通信を記述するのが一般的な使い方である。

　コンストラクタで new されたタイミングで非同期通信が走る、今までならそのコンストラクタの最後にコールバック関数なるものを渡しているところだが、Promise ではその必要はない。

　Promise の処理が完了した後に Promise は then メソッドを呼び出すことになっているのである。正確には resolve() 完了後だが。

　従って、コールバック関数に書いていた処理は全て then メソッドに書けば良いことになる。この then メソッドは then メソッドを繋げることが出来る。 then(1つ目) の後に then(2つ目) の後に then(3つ目) という風にチェーン出来る。この then のチェーンはネストを深くすることなく書ける。

　こうして、コールバック地獄（ネストが深くなる）は Promise の持つ then をチェーンする記法によって解決されたわけである。

　めでたしめでたし、と言いたいところだが、コールバック地獄が解決すると新しい問題を発見してしまう。

　非同期通信を実現する Promise と then というシステムは通常の同期通信の中に混じると、その特殊性が浮彫になっているよね、という話になった。簡単に言えば、非同期通信の記法が独特過ぎて、分かりづらいという話である。

　それはコールバックの時からそうだろうという話でもあるのだが、コールバック関数という非同期通信らしさ（？）が失われたせいか、非同期通信分かりづらいと巷で大評判になって世界が崩壊してビックバンが起きた、とにかく分かりづらさが残っているとのことだった。

　そこで、 async/await が登場する。

### async/await
　async は非同期であることを示す修飾子であり、 await は非同期通信を完了するまで次の処理をしないことを示す修飾子である。

　つまり、

```javascript
await 'Hello' // 'Hello' は非同期とする
'Wolrd'
```

　と書くと `'Hello World'` と出力されるということである。

　こうして、非同期な処理が同期的な処理に混じっても違和感はなくなった。

　めでたしめでたし。

　もちろん、待つ必要がないなら await をつける必要はないし、 then を付ける必要もないし、 コールバックを渡す必要もない。全ては、任意の非同期通信完了後に実行したい処理が連続で存在するという場合を楽で分かりやすくするための旅路であったわけだ。

　ちなみに、 async/await は Promise オブジェクトの存在が前提になっているので、 Promise オブジェクトについて知っておくことは重要だろう。だが、Promise の理解にコールバックが役立つかどうかは分からない。歴史を知ることの方が意義深いかもしれない。

　というわけで、ある特殊な状況についての話が続いたが、ここからは非同期通信を実現する技術というか機能についての話と歴史を見て行く。

## 非同期通信の実装
　非同期通信、というか、非同期処理の実装で見れば、きっと誰もが知っているあの関数が原初と言えるだろう。

　まずはそこから見て行こう。

### setTimeout
　指定時間後に任意の処理を実行する関数である。

　これこそ非同期処理。

　非同期処理なので、Promise のコンストラクタに setTimeout を書いたりしても then の効果を確認出来る。素晴らしい。

　さて。物語は非同期通信へと続く

### XMLHttpRequest
　javascript でHTTP通信をするための標準搭載のAPIである。

　全てはここから始まった。

### JQuery.ajax
　XMLHttpRequest のラッパー。

### Fetch API
　javascript でHTTP通信をするための標準搭載のAPIである。

　ライブラリを入れない場合は、XMLHttpRequest か Fetch API かという話になる。

　Fetch API の方が新しい。

### axios
　Fetch API のラッパー。

## 5(1+4)の非同期 + 3の記法
　細かい仕様の話は知らないので列挙に留まった。一応まとめ的な意味でもう一度列挙。

- setTimeout
- XMLHttpRequest
- JQuery.ajax
- Fetch API
- axios

　ブラウザ上で javascript を使って非同期（処理・通信）をするときの選択肢はこの5つと考えて差し支えないだろう。XMLHttpRequest から axios の4つはHTTP通信をするという点で共通しており、書き替えも出来る。具体的な書き替えについてはインターネット上に大量にあったので、そっちを探して見てみてほしい。

　それぞれの方法毎に書き方の書き替えも出来る（はず）

- コールバック(XMLHttpRequest ~ axios)
- Promise(Fetch API, axios)
- async/await(Fetch API, axios)

　Fetch API が Promise オブジェクトを前提にしているので、コールバックで書き直すのは逆に大変かもしれない。

## まとめ
　非同期通信に現状の最新（2021/04）は `axios + async/await` と言えるだろう。（最新ではないかもしれないが）

　ライブラリを使わない場合は `Fetch API + async/await` と言える。

　別にどの組み合わせでも良いが、新しいAPIと新しい記法を使ったほうが、セキュリティや可読性の点で期待できる。

　もしかしたら、古い書き方じゃないと対応出来ない状況というのもあるかもしれない。適材適所こそプログラムの神髄だと思うので、上手く選びたい。

　Youtube Data API を触ることに関して言えば、 Fetch API で十分と思っているから、それでやってみる。複雑なことをしようとした時に Fetch API では複雑な書き方になったりするかもしれない。その時は axios に変えるべきだろうか。まあなった時に考えればいい。

　というわけで、非同期通信について知見を深めた。

　具体的なコードは一つもこの記事にないが、インターネット上に本当にたくさんあるので30ページぐらい雑に開いて見比べていけば、それだけで随分分かることが増えると思う。理解を深めたい人はそうしたり、リファレンスを見たりとまだまだ出来ることはある。

　私の場合は、 XMLHttpRequest で書こうとして、 ajax で楽に書けるよってなって、 Promise で書けるよって知って、Fetch API を使うよってなって、 axios があるよってなって、 async/await もあるよって言われて、登場人物多すぎるだろおい、となって、いろいろ見て整理して、この記事に至る。漫画の1巻を読んだ後に10巻を読まされて4巻を発見してみたいに、時系列や種類分けも謎だったこともあって何が何だかわからなかったが、こうしてまとめてみると、歴史を紐解いた感じがして良い。ついに非同期通信という正体不明だった連載漫画の購読が許されたわけだ。思ったより長かった。

　これでやっと Youtube Data API を呼び出せる。では。この辺で。

　